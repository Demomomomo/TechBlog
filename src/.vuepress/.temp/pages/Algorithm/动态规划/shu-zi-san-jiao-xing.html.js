export const data = JSON.parse("{\"key\":\"v-c64fcaca\",\"path\":\"/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/shu-zi-san-jiao-xing.html\",\"title\":\"数字三角形模型\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"数字三角形模型\",\"description\":\"求从左上角到右下角走一次的最大或最小值 有一个n*m的网格，每个网格都有一个数，给你规定可以走的方向和走的次数，求从左上角到右下角的最大或者最小值。 常规的一般是可以向下或者向右走，走一次之后求从左上角到右下角的最大值或者最小值，那么状态转移的方程就是： f[i][j]=max(f[i][j],f[i-1][j]); f[i][j]=max(f[i][...\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://mister-hope.github.io/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/shu-zi-san-jiao-xing.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"Demo\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"数字三角形模型\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"求从左上角到右下角走一次的最大或最小值 有一个n*m的网格，每个网格都有一个数，给你规定可以走的方向和走的次数，求从左上角到右下角的最大或者最小值。 常规的一般是可以向下或者向右走，走一次之后求从左上角到右下角的最大值或者最小值，那么状态转移的方程就是： f[i][j]=max(f[i][j],f[i-1][j]); f[i][j]=max(f[i][...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}]]},\"excerpt\":\"\",\"headers\":[{\"level\":2,\"title\":\"求从左上角到右下角走一次的最大或最小值\",\"slug\":\"求从左上角到右下角走一次的最大或最小值\",\"link\":\"#求从左上角到右下角走一次的最大或最小值\",\"children\":[]},{\"level\":2,\"title\":\"从左上角到右下角走两次的最大值\",\"slug\":\"从左上角到右下角走两次的最大值\",\"link\":\"#从左上角到右下角走两次的最大值\",\"children\":[{\"level\":3,\"title\":\"变形\",\"slug\":\"变形\",\"link\":\"#变形\",\"children\":[]}]}],\"readingTime\":{\"minutes\":3.91,\"words\":1172},\"filePathRelative\":\"algorithm/动态规划/shu-zi-san-jiao-xing.md\"}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
