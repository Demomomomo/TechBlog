export const data = JSON.parse("{\"key\":\"v-6b9c925e\",\"path\":\"/algorithm/%E6%90%9C%E7%B4%A2/dfs.html\",\"title\":\"dfs\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"dfs\",\"description\":\"普通dfs 求全排列 原题链接： https://www.acwing.com/problem/content/844/ 题意： 给定一个数字n，按照字典序求出他的全排列 思路： 因为变化是对于整个数组来说的，一个位置我们可以填许多数，但是每个数只能填一次，那么我们就得用一个数组额外记录一个数是否被用过。在每次dfs的时候从1~n遍历，如果i没有被遍历...\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://mister-hope.github.io/algorithm/%E6%90%9C%E7%B4%A2/dfs.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"Demo\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"dfs\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"普通dfs 求全排列 原题链接： https://www.acwing.com/problem/content/844/ 题意： 给定一个数字n，按照字典序求出他的全排列 思路： 因为变化是对于整个数组来说的，一个位置我们可以填许多数，但是每个数只能填一次，那么我们就得用一个数组额外记录一个数是否被用过。在每次dfs的时候从1~n遍历，如果i没有被遍历...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}]]},\"excerpt\":\"\",\"headers\":[{\"level\":2,\"title\":\"普通dfs\",\"slug\":\"普通dfs\",\"link\":\"#普通dfs\",\"children\":[{\"level\":3,\"title\":\"求全排列\",\"slug\":\"求全排列\",\"link\":\"#求全排列\",\"children\":[]},{\"level\":3,\"title\":\"\",\"slug\":\"\",\"link\":\"#\",\"children\":[]}]},{\"level\":2,\"title\":\"记忆化dfs\",\"slug\":\"记忆化dfs\",\"link\":\"#记忆化dfs\",\"children\":[{\"level\":3,\"title\":\"返回以某个点为起点的所有路程的最大长度（无确定终点\",\"slug\":\"返回以某个点为起点的所有路程的最大长度-无确定终点\",\"link\":\"#返回以某个点为起点的所有路程的最大长度-无确定终点\",\"children\":[]},{\"level\":3,\"title\":\"返回的是以某个点为起点走向终点的方案数\",\"slug\":\"返回的是以某个点为起点走向终点的方案数\",\"link\":\"#返回的是以某个点为起点走向终点的方案数\",\"children\":[]}]}],\"readingTime\":{\"minutes\":3.98,\"words\":1193},\"filePathRelative\":\"algorithm/搜索/dfs.md\"}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
