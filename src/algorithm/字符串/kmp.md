---
title: kmp
---

## 概念

时间复杂度：O(n)  

基本操作：看b串是不是a串的子串  

a串：主串，b串：模式串  

核心：i用来扫a串，j用来扫b串，都从0开始，字符串的下标从1开始  

p数组的含义是当b[j+1]不能匹配的时候，以j结尾的字符串前缀等于后缀的最大长度  


思路：$a[i-j+1\to i]$ 和 $b[1\to j]$ 已经匹配，然后比较a[i+1]和b[j+1]  
如果j！=0并且a[i+1]!=b[j+1]的话，我们把b串向后拉至第一个与a串以i结尾的字符相等的位置，即j=p[j],因为 $a[i-j+1\to i]$ 和 $b[1\to j]$ 已经匹配，那么实质上p[j]就是以j结尾的前缀等于后缀的最大长度，也就是求p的方法。  
如果相等的话j++，然后判断：如果j==m的话，就说明模式串在主串中存在。  
```cpp
	int j=0;
	for(int i=0;i<n;i++){
		while(j&&a[i+1]!=b[j+1])j=p[j];
		if(a[i+1]==b[j+1])j++;
		if(j==m){
			printf("%d\n",i-m);//输出首字母在主串中的下标
			j=p[j];//继续寻找匹配（可重叠，不可重叠的话j=0）
		}
	}
```

p[j]就是以j结尾的前缀等于后缀的最大长度（长度小于j，p[1]=0）  
那么就是自己和自己匹配，但是要错一位匹配，如果不错位的话就直接等于本身  
就是i指向的b当主串从1开始，j指向的模式串从0开始  
然后每次循环求的是i+1位置能匹配的最大长度，也就是j  

```cpp
void pre(){
	int j=0;
	p[1]=0;
	for(int i=1;i<m;i++){
		while(j&&b[i+1]!=b[j+1]) j=p[j];
		if(b[i+1]==b[j+1])j++;
		p[i+1]=j;
	}
}
```
## 求一个字符串循环节的最小长度
ne[n]表示去除第一个循环节的后缀长度，求第一个循环节那么就是n-ne[n]  

## 求一个字符串前缀等于后缀的最小长度（最小公共前后缀）

因为要用很多次ne数组，可能会超时，所以用记忆化搜索，如果已经搜出来以j结尾的最小  
公共前后缀的话直接等于j，否则就等于ne[j]

```cpp
每次令j=i，当ne[j]！=0时，j=ne[j]：
	for(int i=1;i<=n;i++){
		int j=i;
		while(ne[j]) {
			if(f[j]) j=f[j];
			else j=ne[j];
		}
		f[i]=j;
	}

```

