---
title: 背包模型
---
## 01背包
容量为v的背包里，有n件物品，每件物品的体积为vi，价值为wi，求不超过背包体积的情况下能获得的物品的最大价值  
有序变无序：从1~i依次遍历，那么处理到i的是吧前i-1个已经被处理过了，可以直接拿着算  
f[i][j]表示在前i个物品中选，总体积不超过j的方案的能获得的最大价值  
对于每个物品i，可以选和不选  
不选：在前i-1个物品中选，体积不超过j的方案的最大价值  
选：在前i-1个物品中选，体积不超过j-vi的方案的最大价值+wi  
f[i][j]=max(f[i-1][j],f[i-1][j-vi]+wi);  
可以优化成一维的数组：f[j]表示体积不超过j的方案的最大价值  
因为每一次更新只和上一层有关  
如果我们按顺序遍历的话，那么我们到j更新的时候所找到的j-vi已经在第i层更新过了，也就是说i已经被拿了，如果我们再按照这个更新的话会再拿一次i  
那么我们i从第一个物品开始遍历，每次j从大到小更新:f[j]=max(f[j],f[j-vi]+wi)  
这样的话当我们更新到j的时候，所用到的j-vi实际上是没有更新过的上一层i-1的最大价值，这样就避免了重复取值  

```cpp
	for(int i=1;i<=n;i++){
		for(int j=m;j>=v[i];j--){
			f[j]=max(f[j],f[j-v[i]]+w[i]);
		}
	}

```

## 完全背包
有一个价值为v的背包，n种物品，每种物品的数量都是无穷的，第i种物品的价值是wi，体积是vi，求不超过背包体积能获得的最大价值
因为每种物品的数量是无限的，所以我们如果正序遍历j的话，到第j-vi的时候虽然是第i层，但是我们是可以多拿几个i取最大的，符合要求（与01的区别就是j反向遍历）  

```cpp
	for(int i=1;i<=n;i++){
		for(int j=v[i];j<=m;j++){
			f[j]=max(f[j],f[j-v[i]]+w[i]);
		}
	}
```
如果要求背包装满的话，那我们设的状态是：f[i][j]表示在前i个物品里恰好选择了体积为j的物品获得的最大价值，那么我们初始化的时候f[0][0]表示在前0个物品选体积恰好为0的最大价值，那么是0，但是f[0][i]表示在前0个物品中选体积恰好为i的最大价值，无解，所以1~n的f[0][i]的值是负无穷，然后我们再正常按01和完全背包做，当最后f[m]是负无穷的话说明没有能正好装满的方案，如果不是那就是最大价值  
memset(f,-0x3f,sizeof f);  
f[0][0]=0;  

## 多重背包

有一个体积为v的背包，n种物品，每个物品的体积是vi，价值是wi，个数是si，求拿的物品的体积不超过背包体积时的最大价值  
用二进制优化  
对于一种背包，我们可以拿0~si个，我们把他分成1,2,4...这种二进制个捆在一起作为一组，那么我们可以用这几组凑出0~si中所有的数，然后对这几组进行01背包问题的拿取就可以了  

```cpp
cin>>n>>m;
	int cnt=0;
	for(int i=1;i<=n;i++){
		int a,b,s;
		cin>>a>>b>>s;
		int k=1;
		while(k<=s){
			cnt++;
			v[cnt]=a*k;
			w[cnt]=b*k;
			s-=k;
			k*=2;
		}
		if(s>0){
			cnt++;
			v[cnt]=s*a;
			w[cnt]=s*b;
		}
	}
	for(int i=1;i<=cnt;i++){
		for(int j=m;j>=v[i];j--){
			f[j]=max(f[j],f[j-v[i]]+w[i]);
		}
	}
	cout<<f[m]<<endl;
```

