---
title: B - Grid Rotations
---
原题链接：https://atcoder.jp/contests/arc153/tasks/arc153_b
题意：有n*m的矩阵，每个方格里有一个小写英文字母，有q个操作，每次询问给你两个值ai，bi，让你执行如下操作：  
在以（1,1）为左上角，（ai，bi）为右下角的矩形内将字母整体旋转180度  
在以（1,bi+1）为左上角，（ai，m）为右下角的矩形内将字母整体旋转180度  
在以（ai+1,1）为左上角，（n，bi）为右下角的矩形内将字母整体旋转180度  
在以（ai+1,bi+1）为左上角，（n，m）为右下角的矩形内将字母整体旋转180度  
让你输出最后的矩阵  
思路：  
我们可以把行和列单独看，对每行来说每次操作实际上就是对行以b,b+1之间为分界线，对前半部分和后半部分分别进行逆转：  
比如序列：  
1,2,3,4,5,6  
那么我们以2,3之间为分界线，把前半部分和后半部分分别逆转得到：  
2,1,6,5,4,3  
可以发现，他是序列6,5,4,3,2,1向左平移4步得到的，因为相对顺序是一定的，那么我们就可以通过找翻转之后1的位置算出偏移量之后，那么翻转之后的数组就是原来数组上的数+偏移量  
那么我们再把这个序列按照5,4之间的分界线逆转，那么就变成了：  
5,6,1,2,3,4  
可以发现，是序列1,2,3,4,5,6向右偏移2步得到的，那么同理根据偏移量也能算出来  
而且还有一个规律：翻转奇数次是原序列逆序的偏移量，偶数次是原序列的偏移量  
那么我们每次就可以分别算出左上角的（1,1）分别在什么位置，算出偏移量之后每个数的位置也就可以算出i’=（i+偏移量）%n  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
int n,m,q;
string s[N];
int xx1[N];
int xx2[N];
int yy1[N];
int yy2[N];
int main(){
	cin>>n>>m;
	for(int i=0;i<n;i++)cin>>s[i];
	cin>>q;
	for(int i=0;i<n;i++) xx1[i]=i,xx2[i]=n-i-1;//横坐标的原序列，横坐标的逆序列
	for(int i=0;i<m;i++) yy1[i]=i,yy2[i]=m-i-1;//纵坐标的原序列，纵坐标的逆序列
	int xx=0,yy=0;//最开始时第一个字母的坐标  
	for(int i=1;i<=q;i++){         
		int a,b;
		cin>>a>>b;
		int x;
		if(xx<=a-1)x=a-1-xx;//如果在a-1之间，说明是按0~a的区间-1之间翻转
		else x=(n-1-xx)+a;//如果在a~n-1之间，按a~n-1的区间翻转
		int y;//y同理
		if(yy<=b)y=b-1-yy;
		else y=(m-1-yy)+b;
		int op1,op2;
		int f;
		xx=x;//每次算出变化后的坐标之后xx，yy也及时更新
		yy=y;
		if(i%2==0){//如果是偶数次操作说明是对原序列
			f=1;//标记是在xx1，yy1的序列进行偏移
			op1=x;//偏移量=后来的坐标-在原序列的坐标，在原序列坐标为0
			op2=y;
		}else{
			f=2;
			op1=x-n+1;//原序列逆序列中坐标为n-1
			op2=y-m+1;//坐标为m-1
		}
		if(i==q){//最后输出
			for(int i=0;i<n;i++){
				for(int j=0;j<m;j++){
                    //当f=1时说明是在xx1，yy1中偏移，因为偏移量=变化后的坐标-在原序列中的坐标，那么对于i来说在原序列中的坐标=（i-op+n)%n，j同理
					if(f==1)cout<<s[xx1[(i-op1+n)%n]][yy1[(j-op2+m)%m]];
					else cout<<s[xx2[(i-op1+n)%n]][yy2[(j-op2+m)%m]];
				}
				cout<<endl;
			}
		}	
}
	return 0;
}
```

