---
title: C. The Very Beautiful Blanket
---
原题链接：https://codeforces.com/contest/1802/problem/C  
题意：给你一个n*m的B矩阵，让你在上面填数，满足对每个他的4 * 4的子矩阵a，满足：  
a[1][1] $\oplus$ a[1][2] $\oplus$ a[2][1] $\oplus$ a[2][2]==a[3][3]  $\oplus$ a[3][4] $\oplus$ a[4][3] $\oplus$ a[4][4]  
a[1][3] $\oplus$ a[1][4] $\oplus$ a[2][3] $\oplus$ a[2][4]==a[3][1] $\oplus$ a[3][2] $\oplus$ a[4][1] $\oplus$ a[4][2]  
要求输出满足条件的所填的不同的数最多的填法。  
思路：  
通过观察可以发现，每个4 * 4的矩阵都可以分成一个2 * 2的子矩阵，并且每个子矩阵满足异或和为0。那么可以构造一个如下的2*2的子矩阵：  
0 1  
2 3  

如果都是这个子矩阵构成的图，那么所有的2*2的矩阵的异或和都为0：  

0 1 0 1 0 1 0 1 0 1  
2 3 2 3 2 3 2 3 2 3  
0 1 0 1 0 1 0 1 0 1  
2 3 2 3 2 3 2 3 2 3  



都是我们想让不同的数尽可能多，那么我们就需要加上差值让他们不相等且差值抵消，参与异或的只有0,1,2,3。  
其二进制分别为：00 01 10 11  
先从左往右看，对于每个2*2的子矩阵，就需要考虑相邻的两个子矩阵的差值。那么可以发现，我们将差值设为4，不会影响0,1,2,3的异或运算且可以抵消。  
比如说对于上图中的a[1][2],a[2][2],a[1][3],a[2][3]来说，a[1][3]和a[2][3]属于右边的2*2的子矩阵，我们将差值和前面的子矩阵的差值设为4的话，a[1][3]和a[2][3]的两个4就可以相互抵消，抵消之后就只有0 1 2 3做异或运算，结果是0.  

0和2各加上4之后对0，1，2，3的运算没有影响，且0和2加上的两个4互相抵消。  


那么我们再从上向下看，考虑上面的子矩阵和下面的子矩阵的差值，由于总个数不到 2^8 个，那么我们就将下面的子矩阵和上面的子矩阵的差值设为 2^9 ，这样抵消之后也只有0,1,2,3参与运算。  


将下面矩阵的0和1加上2^9之后，他们两个的 2^9 互相抵消，那么也就只有0,1,2,3参与异或运算。  



```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=205+10;
int n,m;
int a[N][N];
void sove(){
	cin>>n>>m;
	a[1][1]=0,a[1][2]=1;
	a[2][1]=2,a[2][2]=3;
	for(int j=3;j<=m;j++){
		a[1][j]=a[1][j-2]+4;
		a[2][j]=a[2][j-2]+4;
	}
	for(int i=3;i<=n;i++){
		for(int j=1;j<=m;j++){
			a[i][j]=a[i-2][j]+1024;
		}
	}
	cout<<n*m<<endl;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<a[i][j]<<" ";
		}
		cout<<endl;
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(),cout.tie();
	int t;
	cin>>t;
	while(t--){
		sove();
	}
	return 0;
}

```